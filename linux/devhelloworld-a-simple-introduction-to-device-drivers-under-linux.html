
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>/dev/hello_world: A Simple Introduction to Device 
Drivers under Linux | O'Reilly Media</title>
      </head><body id="linux">
<div id="page">
<div id="header" class="noindex">

<OL>
  <LI> <a href="#SIDevDriv"> A Simple Introduction to Device Drivers 
under Linux</a>
  <LI> <a href="#SCSIDriver">Tour the Linux generic SCSI driver</a>
  <LI> <a href="#DevDriProg">High-Level Device-Driver Programming</a>
</OL>


<a name="SIDevDriv"></a><h2>/dev/hello_world: A Simple Introduction to Device Drivers 
under Linux <a href="http://www.linuxdevcenter.com/pub/a/linux/2007/07/05/devhelloworld-a-simple-introduction-to-device-drivers-under-linux.html?">(Source Origin)</a></h2>
by <a href="http://www.linuxdevcenter.com/pub/au/3084">Valerie Henson</a>
<br>
07/05/2007


<p>Since the misty days of yore, the first step in learning a new
programming language has been writing a program that prints "Hello,
world!" (See the <a href="http://www.roesler-ac.de/wolfram/hello.htm">Hello World Collection</a>
for a list of more than 300 "Hello, world!" examples.) In this article,
we will use the same approach to learn how to write simple Linux kernel
modules and device drivers. We will learn how to print "Hello, world!"
from a kernel module three different ways: <code>printk()</code>, a <code>/proc</code> file, and a device in <code>/dev</code>.</p>

<h3>Preparation: Installing Kernel Module Compilation Requirements</h3>

<p>For the purposes of this article, a kernel module is a piece of
kernel code that can be dynamically loaded and unloaded from the
running kernel. Because it runs as part of the kernel and needs to
interact closely with it, a kernel module cannot be compiled in a
vacuum. It needs, at minimum, the kernel headers and configuration for
the kernel it will be loaded into. Compiling a module also requires a
set of development tools, such as a compiler. For simplicity, we will
briefly describe how to install the requirements to build a kernel
module using Debian, Fedora, and the "vanilla" Linux kernel in tarball
form. In all cases, you must compile your module against the source for
the running kernel (the kernel executing on your system when you load
the module into your kernel).</p>

<p>A note on kernel source location, permissions, and privileges: the kernel source customarily used to be located in <code>/usr/src/linux</code>
and owned by root. Nowadays, it is recommended that the kernel source
be located in a home directory and owned by a non-root user. The
commands in this article are all run as a non-root user, using <code>sudo</code> to temporarily gain root privileges only when necessary. To setup <code>sudo</code>, see the <code>sudo(8)</code>, <code>visudo(8)</code>, and <code>sudoers(5)</code>
main pages. Alternatively, become root, and run all the commands as
root if desired. Either way, you will need root access to follow the
instructions in this article.</p>

<h4>Preparation for Compiling Kernel Modules Under Debian</h4>

<p>The module-assistant package for Debian installs packages and
configures the system to build out-of-kernel modules. Install it with:</p>

<pre><code>$ sudo apt-get install module-assistant</code></pre>

<p>That's it; you can now compile kernel modules. For further reading, the <a href="http://kernel-handbook.alioth.debian.org/">Debian Linux Kernel Handbook</a> has an in-depth discussion on kernel-related tasks in Debian.</p>

<h4>Fedora Kernel Source and Configuration</h4>

<p>The kernel-devel package for Fedora has a package that includes all
the necessary kernel headers and tools to build an out-of-kernel module
for a Fedora-shipped kernel. Install it with:</p>

<pre><code>$ sudo yum install kernel-devel</code></pre>

<p>Again, that's all it takes; you can now compile kernel modules. Related documentation can be found in the <a href="http://docs.fedoraproject.org/release-notes/fc6/en_US/sn-Kernel.html#id2950723">Fedora release notes</a>.</p>

<h4>Vanilla Kernel Source and Configuration</h4>

<p>If you choose to use the vanilla Linux kernel source, you must
configure, compile, install, and reboot into your new vanilla kernel.
This is definitely not the easy route and this article will only cover
the very basics of working with vanilla kernel source.</p>

<p>The canonical Linux source code is hosted at <a href="http://kernel.org/">http://kernel.org</a>.
The most recent stable release is linked to from the front page.
Download the full source release, not the patch. For example, the
current stable release is located at <a href="http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.21.5.tar.bz2">http://kernel.org/pub/linux/kernel/v2.6/linux-2.6.21.5.tar.bz2</a>. For faster download, find the closest mirror from the list at <a href="http://kernel.org/mirrors/">http://kernel.org/mirrors/</a>, and download from there. The easiest way to get the source is using <code>wget</code> in continue mode. HTTP is rarely blocked, and if your download is interrupted, it will continue where it left off.</p>

<pre><code>$ wget -c "http://kernel.org/pub/linux/kernel/v2.6/linux-&lt;version&gt;.tar.bz2"</code></pre>

<p>Unpack the kernel source:</p>

<pre><code>$ tar xjvf linux-&lt;version&gt;.tar.bz2</code></pre>

<p>Now your kernel is located in <i>linux-&lt;version&gt;/</i>. Change directory into your kernel and configure it:</p>

<pre><code>$ cd linux-&lt;version&gt;
$ make menuconfig</code></pre>

<p>A number of really nice make targets exist to automatically build
and install a kernel in many forms: Debian package, RPM package,
gzipped tar, etc. Ask the make system for help to list them all:</p>

<pre><code>$ make help</code></pre>

<p>A target that will work on almost every distro is:</p>

<pre><code>$ make tar-pkg</code></pre>

<p>When finished building, install your new kernel with:</p>

<pre><code>$ sudo tar -C / -xvf linux-&lt;version&gt;.tar</code></pre>

<p>Then create a symbolic link to the source tree in the standard location:</p>

<pre><code>$ sudo ln -s &lt;location of top-level source directory&gt; /lib/modules/'uname -r'/build</code></pre>

<p>Now the kernel source is ready for compiling external modules.
Reboot into your new kernel before loading modules compiled against
this source tree.</p>

<h3>"Hello, World!" Using printk()</h3>

<p>For our first module, we'll start with a module that uses the kernel message facility, <code>printk()</code>, to print "Hello, world!". <code>printk()</code> is basically <code>printf()</code> for the kernel. The output of <code>printk()</code> is printed to the kernel message buffer and copied to <code>/var/log/messages</code> (with minor variations depending on how <code>syslogd</code> is configured).</p>

<p>Download the <a href="http://www.linuxdevcenter.com/linux/2007/07/05/examples/hello_printk.tar.gz">hello_printk module tarball</a> and extract it:</p>

<pre><code>$ tar xzvf hello_printk.tar.gz</code></pre>

<p>This contains two files: <a href="http://www.linuxdevcenter.com/linux/2007/07/05/examples/Makefile"><code>Makefile</code></a>, which contains instructions for building the module, and <a href="http://www.linuxdevcenter.com/linux/2007/07/05/examples/hello_printk.c"><code>hello_printk.c</code></a>, the module source file. First, we'll briefly review the <code>Makefile</code>.</p>

<pre><code>obj-m := hello_printk.o</code></pre>

<p><code>obj-m</code> is a list of what kernel modules to build. The <i>.o</i> and other objects will be automatically built from the corresponding <i>.c</i> file (no need to list the source files explicitly).</p>

<pre><code>KDIR  := /lib/modules/$(shell uname -r)/build</code></pre>

<p><code>KDIR</code> is the location of the kernel source. The current
standard is to link to the associated source tree from the directory
containing the compiled modules.</p>

<pre><code>PWD := $(shell pwd)</code></pre>

<p><code>PWD</code> is the current working directory and the location of our module source files.</p>

<pre><code>default:
    $(MAKE) -C $(KDIR) M=$(PWD) modules</code></pre>

<p><code>default</code> is the default <code>make</code> target; that is, <code>make</code> will execute the rules for this target unless it is told to build another target instead. The rule here says to run <code>make</code> with a working directory of the directory containing the kernel source and compile only the modules in the <code>$(PWD)</code> (local) directory. This allows us to use all the rules for compiling modules defined in the main kernel source tree.</p>

<p>Now, let's run through the code in <code>hello_printk.c</code>.</p>

<pre><code>#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;</code></pre>

<p>This includes the header files provided by the kernel that are
required for all modules. They include things like the definition of
the <code>module_init()</code> macro, which we will see later on.</p>

<pre><code><strong>static int __init
hello_init(void)</strong>
{
        printk("Hello, world!\n");
        return 0;
}</code></pre>

<p>This is the module initialization function, which is run when the module is first loaded. The <code>__init</code> keyword tells the kernel that this code will only be run once, when the module is loaded. The <code>printk()</code> line writes the string "Hello, world!" to the kernel message buffer. The format of <code>printk()</code> arguments is, in most cases, identical to that of <code>printf(3)</code>.</p>

<pre><code><strong>module_init(hello_init)</strong>;</code></pre>

<p>The <code>module_init()</code> macro tells the kernel which function
to run when the module first starts up. Everything else that happens
inside a kernel module is a consequence of what is set up in the module
initialization function.</p>

<pre><code><strong>static void __exit
hello_exit(void)</strong>
{
        printk("Goodbye, world!\n");
}

<strong>module_exit(hello_exit)</strong>;</code></pre>

<p>Similarly, the exit function is run once, upon module unloading, and the <code>module_exit()</code> macro identifies the exit function. The <code>__exit</code> keyword tells the kernel that this code will only be executed once, on module unloading.</p>

<pre><code>MODULE_LICENSE("GPL");
MODULE_AUTHOR("Valerie Henson &lt;val@nmt.edu&gt;");
MODULE_DESCRIPTION("\"Hello, world!\" minimal module");
MODULE_VERSION("printk");</code></pre>

<p><code>MODULE_LICENSE()</code> informs the kernel what license the
module source code is under, which affects which symbols (functions,
variables, etc.) it may access in the main kernel. A GPLv2 licensed
module (like this one) can access all the symbols. Certain module
licenses will taint the kernel, indicating that non-open or untrusted
code has been loaded. Modules without a <code>MODULE_LICENSE()</code>
tag are assumed to be non-GPLv2 and will result in tainting the kernel.
Most kernel developers will ignore bug reports from tainted kernels
because they do not have access to all the source code, which makes
debugging much more difficult. The rest of the <code>MODULE_*()</code> macros provide useful identifying information about the module in a standard format.</p>


<p class="secondary"><b>/dev/hello_world: A Simple Introduction to Device Drivers under Linux</b><br>


<p>Now, to compile and run the code. Change into the directory and build the module:</p>



<br clear="left">

<pre><code>$ cd hello_printk
$ make</code></pre>

<p>Then, load the module, using <code>insmod</code>, and check that it printed its message, using <code>dmesg</code>, a program that prints out the kernel message buffer:</p>

<pre><code>$ sudo insmod ./hello_printk.ko
$ dmesg | tail</code></pre>

<p>You should see "Hello, world!" in the output from <code>dmesg</code>. Now unload the module, using <code>rmmod</code>, and check for the exit message:</p>

<pre><code>$ sudo rmmod hello_printk
$ dmesg | tail</code></pre>

<p>You have successfully compiled and installed a kernel module!</p>

<h3>Hello, World! Using /proc</h3>

<p>One of the easiest and most popular ways to communicate between the kernel and user programs is via a file in the <code>/proc</code> file system. <code>/proc</code>
is a pseudo-file system, where reads from files return data
manufactured by the kernel, and data written to files is read and
handled by the kernel. Before <code>/proc</code>, all user-kernel
communication had to happen through a system call. Using a system call
meant choosing between finding a system call that already behaved the
way you needed (often not possible), creating a new system call
(requiring global changes to the kernel, using up a system call number,
and generally frowned upon), or using the catch-all <code>ioctl()</code> system call, which requires the creation of a special file that the <code>ioctl()</code> operates on (complex and frequently buggy, and very much frowned upon). <code>/proc</code>
provides a simple, predefined way to pass data between the kernel and
userspace with just enough framework to be useful, but still enough
freedom that kernel modules can do what they need.</p>

<p>For our purposes, we want a file in <code>/proc</code> that will return "Hello, world!" when read. We'll use <code>/proc/hello_world</code>. Download and extract the <a href="http://www.linuxdevcenter.com/linux/2007/07/05/examples/hello_proc.tar.gz">hello_proc module tarball</a>. We'll run through the code in <a href="http://www.linuxdevcenter.com/linux/2007/07/05/examples/hello_proc.c"><code>hello_proc.c</code></a>.</p>

<pre><code>#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/proc_fs.h&gt;</code></pre>

<p>This time, we add the header file for <code>procfs</code>, which includes support for registering with the <code>/proc</code> file system.</p>

<p>The next function will be called when a process calls <code>read()</code> on the <code>/proc</code> file we will create. It is simpler than a completely generic <code>read()</code> system call implementation because we only allow the "Hello, world!" string to be read all at once.</p>

<pre><code><strong>static int
hello_read_proc(char *buffer, char **start, off_t offset, int size, int *eof,
                void *data)</strong>
{</code></pre>

<p>The arguments to this function deserve an explicit explanation. <code>buffer</code> is a pointer to a kernel buffer where we write the output of the <code>read()</code>. <code>start</code> is used for more complex <code>/proc</code> files; we ignore it here. <code>offset</code> tells us where to begin reading inside the "file"; we only allow an offset of 0 for simplicity. <code>size</code> is the size of the buffer in bytes; we must check that we don't write past the end of the buffer accidentally. <code>eof</code> is a short cut for indicating EOF (end of file) rather than the usual method of calling <code>read()</code> again and getting 0 bytes back. <code>data</code> is again for more complex <code>/proc</code> files and ignored here.</p>

<p>Now, for the body of the function:</p>

<pre><code>        char *hello_str = "Hello, world!\n";
        int len = strlen(hello_str); /* Don't include the null byte. */
        /*
         * We only support reading the whole string at once.
         */
        if&lt;/ (size &lt; len)
                return&lt; -EINVAL;
        /*
         * If file position is non-zero, then assume the string has
         * been read and indicate there is no more data to be read.
         */
        if (offset != 0)
                return 0;
        /*
         * We know the buffer is big enough to hold the string.
         */
        strcpy(buffer, hello_str);
        /*
         * Signal EOF.
         */
        *eof = 1;

        return len;

}</code></pre>

<p>Next, we need to register with the <code>/proc</code> subsystem in our module initialization function.</p>

<pre><code><strong>static int __init
hello_init(void)</strong>
{
        /*
         * Create an entry in /proc named "hello_world" that calls
         * hello_read_proc() when the file is read.
         */
        if (create_proc_read_entry("hello_world", 0, NULL, hello_read_proc,
                                    NULL) == 0) {
                printk(KERN_ERR
                       "Unable to register \"Hello, world!\" proc file\n");
                return -ENOMEM;
        }

        return 0;
}

<strong>module_init(hello_init)</strong>;</code></pre>

<p>And unregister when the module unloads (if we didn't do this, when a process attempted to read <code>/proc/hello_world</code>, the <code>/proc</code> file system would try to execute a function that no longer existed and the kernel would panic).</p>

<pre><code><strong>static void __exit
hello_exit(void)</strong>
{
        remove_proc_entry("hello_world", NULL);
}

<strong>module_exit(hello_exit)</strong>;

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Valerie Henson &lt;val@nmt.edu&gt;");
MODULE_DESCRIPTION("\"Hello, world!\" minimal module");
MODULE_VERSION("proc");</code></pre>

<p>Then, we're ready to compile and load the module:</p>

<pre><code>$ cd hello_proc
$ make
$ sudo insmod ./hello_proc.ko</code></pre>

<p>Now, there is a file named <code>/proc/hello_world</code> that will produce "Hello, world!" when read:</p>

<pre><code>$ cat /proc/hello_world
Hello, world!</code></pre>

<p>You can create many more <code>/proc</code> files from the same driver, add routines to allow writing to <code>/proc</code> files, create directories full of <code>/proc</code> files, and more. For anything more complicated than this driver, it is easier and safer to use the <code>seq_file</code> helper routines when writing <code>/proc</code> interface routines. For further reading, see <a href="http://lwn.net/Articles/22355/">Driver porting: The seq_file interface</a>.</p>

<h3>Hello, World! Using /dev/hello_world</h3>

<p>Now we will implement "Hello, world!" using a device file in <code>/dev</code>, <code>/dev/hello_world</code>. Back in the old days, a device file was a special file created by running a crufty old shell script named <code>MAKEDEV</code> which called the <code>mknod</code> command to create every possible file in <code>/dev</code>, regardless of whether the associated device driver would ever run on that system. The next iteration, <code>devfs</code>, created <code>/dev</code>
files when they were first accessed, which led to many interesting
locking problems and wasteful attempts to open device files to see if
the associated device existed. The current version of <code>/dev</code> support is called <code>udev</code>, since it creates <code>/dev</code> links with a userspace program. When kernel modules register devices, they appear in the <code>sysfs</code> file system, mounted on <code>/sys</code>. A userspace program, <code>udev</code>, notices changes in <code>/sys</code> and dynamically creates <code>/dev</code> entries according to a set of rules usually located in <code>/etc/udev/</code>.</p>

<p>Download the <a href="http://www.linuxdevcenter.com/linux/2007/07/05/examples/hello_dev.tar.gz">hello world module tarball</a>. We'll go through <a href="http://www.linuxdevcenter.com/linux/2007/07/05/examples/hello_dev.c"><code>hello_dev.c</code></a>.</p>

<pre><code>#include &lt;linux/fs.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/miscdevice.h&gt;&lt;
#include &lt;linux/module.h&gt;

#include &lt;asm/uaccess.h&gt;</code></pre>

<p>As we can see from looking at the necessary header files, creating a
device requires quite a bit more kernel support than our previous
methods. <code>fs.h</code> includes the definitions for a file operations structure, which we must fill out and attach to our <code>/dev</code> file. <code>miscdevice.h</code> includes support for registering a miscellaneous device file. <code>asm/uaccess.h</code> includes functions for testing whether we can read or write to userspace memory without violating permissions.</p>

<p><code>hello_read()</code> is the function called when a process calls read() on <code>/dev/hello</code>. It writes "Hello, world!" to the buffer passed in the <code>read()</code> call.</p>

<pre><code><strong>static ssize_t hello_read(struct file * file, char * buf, 
                          size_t count, loff_t *ppos)</strong>
{
        char *hello_str = "Hello, world!\n";
        int len = strlen(hello_str); /* Don't include the null byte. */
        /*
         * We only support reading the whole string at once.
         */
        if (count &lt; len)
                return -EINVAL;
        /*
         * If file position is non-zero, then assume the string has
         * been read and indicate there is no more data to be read.
         */
        if (*ppos != 0)
                return 0;
        /*
         * Besides copying the string to the user provided buffer,
         * this function also checks that the user has permission to
         * write to the buffer, that it is mapped, etc.
         */
        if (copy_to_user(buf, hello_str, len))
                return -EINVAL;
        /*
         * Tell the user how much data we wrote.
         */
        *ppos = len;

        return len;
}</code></pre>

<p class="secondary"><b>/dev/hello_world: A Simple Introduction to Device Drivers under Linux</b><br>


<p>Next, we create the file operations struct defining what actions to
take when the file is accessed. The only file operation we care about
is read.</p>


<br clear="left"><!-- me -->

<pre><code>static const struct file_operations hello_fops = {
        .owner                = THIS_MODULE,
        .read                = hello_read,
};</code></pre>

<p>Now, create the structure containing the information needed to register a miscellaneous device with the kernel.</p>

<pre><code>static struct miscdevice hello_dev = {
        /*
         * We don't care what minor number we end up with, so tell the
         * kernel to just pick one.
         */
        MISC_DYNAMIC_MINOR,
        /*
         * Name ourselves /dev/hello.
         */
        "hello",
        /*
         * What functions to call when a program performs file
         * operations on the device.
         */
        &amp;hello_fops
};</code></pre>

<p>As usual, we register the device in the module's initialization function.</p>

<pre><code><strong>static int __init
hello_init(void)</strong>
{
        int ret;

        /*
         * Create the "hello" device in the /sys/class/misc directory.
         * Udev will automatically create the /dev/hello device using
         * the default rules.
         */
        ret = misc_register(&amp;hello_dev);
        if (ret)
                printk(KERN_ERR
                       "Unable to register \"Hello, world!\" misc device\n");

        return ret;
}

<strong>module_init(hello_init)</strong>;</code></pre>

<p>And remember to unregister the device in the exit function.</p>
<!-- sidebar begins -->
<!-- don't move sidebars -->
<!-- sidebar ends -->


<pre><code><strong>static void __exit
hello_exit(void)</strong>
{
        misc_deregister(&amp;hello_dev);
}

<strong>module_exit(hello_exit)</strong>;

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Valerie Henson &lt;val@nmt.edu&gt;");
MODULE_DESCRIPTION("\"Hello, world!\" minimal module");
MODULE_VERSION("dev");</code></pre>

<p>Compile and load the module:</p>

<pre><code>$ cd hello_dev
$ make
$ sudo insmod ./hello_dev.ko</code></pre>

<p>Now there is a device named <code>/dev/hello</code> that will produce "Hello, world!" when read by root:</p>

<pre><code>$ sudo cat /dev/hello
Hello, world!</code></pre>

<p>But we can't read it as a regular user:</p>

<pre><code>$ cat /dev/hello
cat: /dev/hello: Permission denied
$ ls -l /dev/hello
crw-rw---- 1 root root 10, 61 2007-06-20 14:31 /dev/hello</code></pre>

<p>This is what happens with the default udev rule, which says that when a miscellaneous device appears, create a file named <code>/dev/&lt;device name&gt;</code>
and give it permissions 0660 (owner and group have read-write access,
everyone else has no access). We would really like instead for the
device be readable by regular users and have a link to it named <code>/dev/hello_world</code>. In order to do this, we'll write a udev rule.</p>

<p>The udev rule has to do two things: create a symbolic link and
change the permissions on device to make world readable. The rule that
accomplishes this is:</p>

<pre><code>KERNEL=="hello", SYMLINK+="hello_world", MODE="0444"</code></pre>

<p>We'll break the rule down into parts and explain each part.</p>

<p><code>KERNEL=="hello"</code> says to execute the rest of the rule when a device with a name the same as this string (the <code>==</code> operator means "comparison") appears in <code>/sys</code>. The <code>hello</code> device appeared when we called <code>misc_register()</code> with a structure containing the device name "hello". See the result for yourself in <code>/sys</code>:</p>

<pre><code>$ ls -d /sys/class/misc/hello/
/sys/class/misc/hello/</code></pre>

<p><code>SYMLINK+="hello_world"</code> says to add (the <code>+=</code> operator means append) <code>hello_world</code>
to the list of symbolic links that should be created when the device
appears. In our case, we know this is the only symbolic link in the
list, but other devices may have multiple udev rules that create
multiple different symbolic links, so it is good practice add to the
list instead of assigning to it.</p>

<p><code>MODE="0444"</code> says to set the permissions of the original
device file to the 0444 mode, which allows owner, group, and world all
to read the file.</p>

<p>In general, it is very important to use the correct operator (<code>==</code>, <code>+=</code>, or <code>=</code>), or unexpected things will happen.</p>

<p>Now that we understand what the rule does, let's install it in the <code>/etc/udev</code> directory. Udev rules files are arranged in much the same manner as the System V init scripts in <code>/etc/init.d/</code>. Udev executes every script the udev rules directory, <code>/etc/udev/rules.d</code>, in alphabetical/numerical order. Like System V init scripts, the files in the <code>/etc/udev/rules.d</code>
directory are usually symbolic links to the real rules files, with the
symbolic links named so that the rules will be executed in the correct
order.</p>

<p>Copy the <code>hello.rules</code> file from the <code>hello_dev</code> directory into the <code>/etc/udev/</code> directory and create a link to it that will be executed before any other rules file:</p>

<pre><code>$ sudo cp hello.rules /etc/udev/
$ sudo ln -s ../hello.rules /etc/udev/rules.d/010_hello.rules</code></pre>

<p>Now, reload the hello world driver and look at the new <code>/dev</code> entries:</p>

<pre><code>$ sudo rmmod hello_dev
$ sudo insmod ./hello_dev.ko
$ ls -l /dev/hello*
cr--r--r-- 1 root root 10, 61 2007-06-19 21:21 /dev/hello
lrwxrwxrwx 1 root root      5 2007-06-19 21:21 /dev/hello_world -&gt; hello</code></pre>

<p>Now we have /dev/hello_world! Finally, check that you can read the "Hello, world!" devices as a normal user:</p>

<pre><code>$ cat /dev/hello_world
Hello, world!
$ cat /dev/hello
Hello, world!</code></pre>

<p>For more details on writing udev rules, see <a href="http://www.reactivated.net/writing_udev_rules.html">Writing udev rules</a>, by Daniel Drake.</p>

<p><i>
<a href="http://www.linuxdevcenter.com/pub/au/3084">Valerie Henson</a> 
is a Linux consultant specializing in file systems, and maintainer of the TCP/IP Drinking Game.

</i></p>

<hr noshade="noshade" size="1">

<p>Return to <a href="http://www.linuxdevcenter.com/">LinuxDevCenter.com</a>.</p>


<a name="SCSIDriver"></a><h2>Tour the Linux generic SCSI driver
<a href="http://www.ibm.com/developerworks/linux/library/l-scsi-api/index.html?
ca=dgr-btw01Linux-SCSI&S_TACT=105AGX59&S_CMP=grsitebtw01">(Source Origin)</a></h2>

<p id="subtitle"><em>Dive into the Linux generic SCSI driver API and surface with 
a usage example</em></p>
<p>Level: Intermediate</p><p><a href="#author">Mao Tao</a> (<a href="mailto:taomaoy@cn.ibm.com?subject=Tour%20the%20Linux%20generic%20SCSI%20driver">taomaoy@cn.ibm.com</a>), 
Software Engineer, IBM<br></p><p> 25 Feb  2009</p>
<blockquote>Computers control and transfer data to SCSI devices via SCSI commands. 
In this article, the author introduces some of the SCSI commands and methods of 
executing SCSI commands when using SCSI API in Linux. He provides background on the 
SCSI client/server model and the storage SCSI command. Next, he explains the Linux 
generic SCSI driver API and offers an example of using a system that focuses on 
executing the inquiry command using the generic driver.</blockquote>

  <p><a name="N10075"><span class="atitle">The SCSI client/server
     model</span></a></p>

<p> During the communication between a host and storage, a host generally acts
    as a <i>SCSI initiator</i>. In computer storage, the SCSI initiator is the
    endpoint that initiates a SCSI session, meaning it sends a SCSI command.
    The storage often acts as a SCSI target which receives and processes SCSI
    commands. The SCSI target waits for the initiator's commands and then
    provides required input/output data transfers. </p>
<p> The target usually provides the initiators one or more <i>logical unit
        numbers</i> (LUN). In computer storage, a LUN is simply the number
    assigned to a logical unit. A logical unit is a SCSI protocol entity, the
    only one which may be addressed by the actual I/O operations. Each SCSI
    target provides one or more logical units; it does not perform I/O as
    itself, but on behalf of a specific logical unit. </p>
<p> In a storage area, a LUN often represents a SCSI disk on which a host can
    perform a read and write operation. Figure 1 shows how the SCSI
    client/server model works. </p>


    <br><a name="fig1"><b>Figure 1. The SCSI
        client/server model</b></a><br>
    <img alt="The SCSI client/server model" 
src="http://www.ibm.com/developerworks/linux/library/l-scsi-api/figure1.gif" 
height="242" width="421">
<br>

<p> The initiator first sends commands to the target which decodes the command
    and then may request data from the initiator or send data to the
    initiator. After that, the target sends the status to the initiator. If
    the status is bad, then the initiator sends request sense command to the
    target. The target returns the sense data to indicate what went wrong. </p>
<p> Now let's focus on storage-related SCSI commands. </p>

<br><p><a name="N1009F"><span class="atitle">Storage-related
    SCSI commands</span></a></p>

<p> Storage-related SCSI commands are defined mainly in the SCSI Architecture
    Model (SAM), SCSI Primary Commands (SPC), and SCSI Block Commands (SBC): </p>

<ul>
    <li>SAM defines the SCSI systems model, the functional partitioning of the
        SCSI standard set, and the requirements applicable to all SCSI
        implementations and implementation standards.</li>
    <li>SPC defines behaviors that are common to all SCSI device models.</li>
    <li>SBC defines the command set extensions to facilitate operation of SCSI
        direct-access block devices.</li>
</ul>

<p> Each SCSI command is described by a Command Descriptor Block (CDB) which
    defines the operations to be performed by the SCSI device. The SCSI
    commands involve data commands which are used for transferring data from
    or to SCSI devices and non-data commands which request or set the
    configure parameters of a SCSI device. In Table 1, you can see the most
    commonly used commands. </p>

<br><a name="table1"><b>Table 1. Most commonly used SCSI
    commands</b></a><br>
<table class="data-table-1" summary="Most commonly used SCSI commands" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><th>Command</th><th>Description</th></tr><tr><td>Inquiry</td><td>Request general information of the target device.</td></tr><tr><td>Test/Unit/Ready</td><td>Check whether the target device is ready for the transfer
            operation.</td></tr><tr><td>READ</td><td>Transfer data from SCSI target device.</td></tr><tr><td>WRITE</td><td>Transfer data to SCSI target device.</td></tr><tr><td>Request Sense&nbsp;&nbsp;&nbsp;</td><td>Request the sense data of the last command.</td></tr><tr><td>Read Capacity&nbsp;&nbsp;&nbsp;</td><td>Request the storage capacity information.</td></tr></tbody></table>

<p> All SCSI commands should begin with an operation code as the first byte.
    This indicates what operation it represents. All SCSI commands should also
    contain a control byte. This is typically the last byte of the command,
    used for vendor-specific information and other uses. </p>
<p> Now on to the generic SCSI driver. </p>

<br><p><a name="N1010C"><span class="atitle">The Linux generic
    SCSI driver</span></a></p>

<p> SCSI devices under Linux are often named to help the user identify the
    device. For example, the first SCSI CD-ROM is /dev/scd0. SCSI disks are
    labeled /dev/sda, /dev/sdb, /dev/sdc, etc. Once device initialization is
    complete, the Linux SCSI disk driver interfaces (sd) only send
    <code>SCSI READ</code> and <code>WRITE</code>
    commands. </p>
<p> These SCSI devices may also have generic names or interfaces, such as
    /dev/sg0, /dev/sg1 or /dev/sga, /dev/sgb, etc. With these generic driver
    interfaces, you can directly send SCSI commands to SCSI devices, bypassing
    a file system which is normally created on a SCSI disk and mounted under a
    directory. In Figure 2, you can see how different applications communicate
    with SCSI devices. </p>


    <br><a name="fig2"><b>Figure 2. The myriad ways
        of communicating with a SCSI device</b></a><br>
    <img alt="The myriad ways of communicating with a SCSI device" 
src="http://www.ibm.com/developerworks/linux/library/l-scsi-api/figure2.gif" 
height="233" width="478">
<br>

<p> With Linux generic driver interface, you can build applications which can
    send more kinds of SCSI commands to SCSI devices. In other words, you have
    a choice. To determine which SCSI device stands for which sg interface,
    you can use the <code>sg_map</code> command (within Debian sg3-utils package) 
    to list the maps: With Red Hat/Fedora or Debian family, <code>sg3_utils</code> 
    should be installed. Let's take a look at how a typical SCSI system call command
    would be performed. </p>

<pre class="displaycode">[root@taomaoy ~]# sg_map -i
/dev/sg0  /dev/sda   ATA       ST3160812AS       3.AA
/dev/sg1  /dev/scd0  HL-DT-ST  RW/DVD GCC-4244N  1.02
</pre>

<P> On kubuntu:
<PRE>
$ sudo sg_map -i
/dev/sg0  /dev/scd0  PIONEER   DVD-ROM DVD-126P  1.02
/dev/sg1  /dev/scd1  SONY      DVD RW DRU-820A   1.0a
/dev/sg2  /dev/sda   ATA       ST3808110AS       3.AA
/dev/sg3  /dev/sdb   ATA       ST3200827AS       3.AA
</PRE>

<h4><a name="N10142"><span class="atitle">The typical SCSI
    generic driver commands</span></a></h4>

<p> SCSI generic driver supports many typical system calls for character
    device, such as <code>open()</code>,
    <code>close()</code>, <code>read()</code>,
    <code>write</code>, <code>poll()</code>,
    <code>ioctl()</code>. The procedure of sending SCSI commands
    to a specific SCSI device is also very simple: </p>

<ol>
    <li>Open the SCSI generic device file (such as sg1) to get the file
        descriptor of SCSI device.</li>
    <li>Prepare the SCSI command.</li>
    <li>Set related memory buffers.</li>
    <li>Call the <code>ioctl()</code> function to execute the
        SCSI command.</li>
    <li>Close the device file.</li>
</ol>

<p> A typical <code>ioctl()</code> function could be written
    like this: <code>ioctl(fd,SG_IO,p_io_hdr);</code>. </p>
<p> The <code>ioctl()</code> function here requires three
    parameters: </p>
<ol>
    <li><code>fd</code> is the file descriptor of the device
        file. After the device file is successfully opened by calling
        <code>open()</code>, this parameter could be
        acquired.</li>
    <li><code>SG_IO</code> indicates that an
        <code>sg_io_hdr</code> object is handed as the third
        parameter of the <code>ioctl()</code> function and will
        return when the SCSI command is finished.</li>
    <li>The <code>p_io_hdr</code> is a pointer to the
        <code>sg_io_hdr</code> object which contains the SCSI
        command and other settings.</li>
</ol>

<p> The most important data structure for SCSI generic driver is <code>struct 
    sg_io_hdr</code>, defined in <code>/usr/include/scsi/sg.h</code>, contains 
    information on how the SCSI command would be performed.
    Listing 1 shows the definition of the structure. </p>

<br><a name="listing1"><b>Listing 1. Definition of struct sg_io_hdr</b></a><br><table border="0" cellpadding="0" cellspacing="0" width="75%"><tbody><tr><td class="code-outline"><pre class="displaycode">
typedef struct sg_io_hdr
{
    int interface_id;               /* [i] 'S' (required) */
    int dxfer_direction;            /* [i] */
    unsigned char cmd_len;          /* [i] */
    unsigned char mx_sb_len;        /* [i] */
    unsigned short iovec_count;     /* [i] */
    unsigned int dxfer_len;         /* [i] */
    void * dxferp;                  /* [i], [*io] */
    unsigned char * cmdp;           /* [i], [*i]  */
    unsigned char * sbp;            /* [i], [*o]  */
    unsigned int timeout;           /* [i] unit: millisecs */
    unsigned int flags;             /* [i] */
    int pack_id;                    /* [i-&gt;o] */
    void * usr_ptr;                 /* [i-&gt;o] */
    unsigned char status;           /* [o] */
    unsigned char masked_status;    /* [o] */
    unsigned char msg_status;       /* [o] */
    unsigned char sb_len_wr;        /* [o] */
    unsigned short host_status;     /* [o] */
    unsigned short driver_status;   /* [o] */
    int resid;                      /* [o] */
    unsigned int duration;          /* [o] */
    unsigned int info;              /* [o] */
} sg_io_hdr_t;  /* 64 bytes long (on i386) */
</pre></td></tr></tbody></table><br>

<p> Not all the fields in this structure are required, so only those that are
    commonly used are introduced here: </p>

<ul>
    <li><code>interface_id</code>: Should always be
        <code>S</code>.</li>
    <li><code>dxfer_direction</code>: Used for data transfer
        direction, could be one of the following values: <ul>
            <li><code>SG_DXFER_NONE</code>: No data transfer is
                needed. For example, a SCSI Test Unit Ready command.</li>
            <li><code>SG_DXFER_TO_DEV</code>: Data is
                transferred to device. A SCSI WRITE command.</li>
            <li><code>SG_DXFER_FROM_DEV</code>: Data is
                transferred from device. A SCSI READ command.</li>
            <li><code>SG_DXFER_TO_FROM_DEV</code>: Data is
                transferred both ways.</li>
            <li><code>SG_DXFER_UNKNOWN</code>: The data transfer
                direction is unknown.</li>
        </ul></li>
    <li><code>cmd_len</code>: The length in bytes of
        <code>cmdp</code> that points to the SCSI command.</li>
    <li><code>mx_sb_len</code>: The maximum size that can be
        written back to the <code>sbp</code> when a
        <code>sense_buffer</code> is output.</li>
    <li><code>dxfer_len</code>: The length of the user memory
        for data transfer.</li>
    <li><code>dxferp</code>: A pointer to user memory of at
        least <code>dxfer_len</code> bytes in length for data
        transfer.</li>
    <li><code>cmdp</code>: A pointer to the SCSI command to be
        executed.</li>
    <li><code>sbp</code>: A pointer to sense buffer.</li>
    <li><code>timeout</code>: Used to timeout the given
        command.</li>
    <li><code>status</code>: SCSI status byte as defined by the
        SCSI standard.</li>
</ul>

<p> In summary, when data is about to be transferred using this method,
    <code>cmdp</code> must point to SCSI CDB whose length is
    stored in <code>cmd_len</code>;
    <code>sbp</code> points to a user memory whose maximum
    length is <code>mx_sb_len</code>. In case an error occurs,
    the sense data would be written back to this place.
    <code>dxferp</code> points to a memory, the data would be
    transferred from or to the SCSI device depending on the
    <code>dxfer_direction</code>. </p>
<p> Finally, let's look at an inquiry command and how it would execute using
    the generic driver. </p>


<h4><a name="N10256"><span class="atitle">Example: Executing
    an inquiry command</span></a></h4>

<p> An inquiry command is the most common SCSI command that all SCSI devices
    implement. This command is used to request the basic information of the
    SCSI device and is often used as a <i>ping</i> operation to test to see if
    the SCSI device is online. Table 2 shows how the SCSI standard is defined. </p>


<br><a name="table2"><b>Table 2. The inquiry command format
    definition</b></a><br>
<table class="data-table-1" summary="The inquiry command format definition" border="0" cellpadding="0" cellspacing="0" width="75%"><tbody><tr><th scope="col"></th><th scope="col">bit 7</th><th scope="col">bit 6</th><th scope="col">bit 5</th><th scope="col">bit 4</th><th scope="col">bit 3</th><th scope="col">bit 2</th><th scope="col">bit 1</th><th scope="col">bit 0</th></tr><tr><td>byte 0</td><td colspan="8" align="center">Operation code = 12h</td></tr><tr><td>byte 1</td><td colspan="3" bgcolor="#999999">LUN</td><td colspan="4" bgcolor="#cccccc">Reserved</td><td bgcolor="#999999">EVPD</td></tr><tr><td>byte 2</td><td colspan="8" align="center">Page code</td></tr><tr><td>byte 3</td><td colspan="8" align="center" bgcolor="#cccccc">Reserved</td></tr><tr><td>byte 4</td><td colspan="8" align="center">Allocation length</td></tr><tr><td>byte 5</td><td colspan="8" align="center" bgcolor="#cccccc">Control</td></tr></tbody></table>

<p> If the EVPD parameter bit (for <i>enable vital product data</i>) is zero
    and the Page Code parameter byte is zero, then the target will return the
    standard inquiry data. If the EVPD parameter is one, then the target would
    return vendor-specific data according to the page code fields. </p>

<p> Listing 2 shows the source code clips of using the SCSI generic API. Let's
    first look at the examples of setting
    <code>sg_io_hdr</code>. </p>

<br><a name="listing2"><b>Listing 2. Setting sg_io_hdr</b></a><br><table border="0" cellpadding="0" cellspacing="0" width="75%"><tbody><tr><td class="code-outline"><pre class="displaycode">
struct  sg_io_hdr * init_io_hdr() {
  struct sg_io_hdr * p_scsi_hdr = (struct sg_io_hdr *)malloc(sizeof(struct sg_io_hdr));
  memset(p_scsi_hdr, 0, sizeof(struct sg_io_hdr));
  if (p_scsi_hdr) {
   p_scsi_hdr-&gt;interface_id = 'S'; /* this is the only choice we have! */
    /* this would put the LUN to 2nd byte of cdb*/
    p_scsi_hdr-&gt;flags = SG_FLAG_LUN_INHIBIT; 
  }
  return p_scsi_hdr;
}

void destroy_io_hdr(struct sg_io_hdr * p_hdr) {
    if (p_hdr) {
        free(p_hdr);
    }
}

void set_xfer_data(struct sg_io_hdr * p_hdr, void * data, unsigned int length) {
    if (p_hdr) {
        p_hdr-&gt;dxferp = data;
        p_hdr-&gt;dxfer_len = length;
    }
}

void set_sense_data(struct sg_io_hdr * p_hdr, unsigned char * data,
        unsigned int length) {
    if (p_hdr) {
        p_hdr-&gt;sbp = data;
        p_hdr-&gt;mx_sb_len = length;
    }
}
</pre></td></tr></tbody></table><br>

<p> These functions are used for setting the
    <code>sg_io_hdr</code> object. Some of the fields point to
    user space memory; when the execution is finished, inquiry output data
    from the SCSI command is copied into the memory where
    <code>dxferp</code> points to. If there is an error and the
    sense data is required, the sense data would be copied to where
    <code>sbp</code> points to. The example for sending an
    inquiry command to a SCSI target is shown in Listing 3. </p>

<br><a name="listing3"><b>Listing 3. Sending an inquiry command to a SCSI target</b></a><br><table border="0" cellpadding="0" cellspacing="0" width="75%"><tbody><tr><td class="code-outline"><pre class="displaycode">
int execute_Inquiry(int fd, int page_code, int evpd, struct sg_io_hdr * p_hdr) {
    unsigned char cdb[6];
    /* set the cdb format */
    cdb[0] = 0x12; /*This is for Inquery*/
    cdb[1] = evpd &amp; 1;
    cdb[2] = page_code &amp; 0xff;
    cdb[3] = 0;
    cdb[4] = 0xff;
    cdb[5] = 0; /*For control filed, just use 0 */
    
    p_hdr-&gt;dxfer_direction = SG_DXFER_FROM_DEV;
    p_hdr-&gt;cmdp = cdb;
    p_hdr-&gt;cmd_len = 6;

    int ret = ioctl(fd, SG_IO, p_hdr);
    if (ret&lt;0) {
        printf("Sending SCSI Command failed.\n");
        close(fd);
        exit(1);
    }
    return p_hdr-&gt;status;
}
</pre></td></tr></tbody></table><br>

<p> So the function first prepares the CDB according to the inquiry standard
    format and then calls the <code>ioctl()</code> function,
    handing file descriptor <code>SG_IO</code>, and the
    <code>sg_io_hdr</code> object; the return status is stored
    in the "status" field of the <code>sg_io_hdr</code> object. </p>
<p> Now let's see how the application program uses this function to execute
    the inquiry command (Listing 4): </p>

<br><a name="listing4"><b>Listing 4. Application program executes the inquiry command</b></a><br><table border="0" cellpadding="0" cellspacing="0" width="75%"><tbody><tr><td class="code-outline"><pre class="displaycode">
unsigned char sense_buffer[SENSE_LEN];
unsigned char data_buffer[BLOCK_LEN*256];
void test_execute_Inquiry(char * path, int evpd, int page_code) {
    struct sg_io_hdr * p_hdr = init_io_hdr();
    set_xfer_data(p_hdr, data_buffer, BLOCK_LEN*256);
    set_sense_data(p_hdr, sense_buffer, SENSE_LEN);
    int status = 0;
    int fd = open(path, O_RDWR);
    if (fd&gt;0) {
        status = execute_Inquiry(fd, page_code, evpd, p_hdr);
        printf("the return status is %d\n", status);
        if (status!=0) {
show_sense_buffer(p_hdr);
        } else{
show_vendor(p_hdr);
show_product(p_hdr);
show_product_rev(p_hdr);
        }
    } else {
        printf("failed to open sg file %s\n", path);
    }
    close(fd);
    destroy_io_hdr(p_hdr);
}
</pre></td></tr></tbody></table><br>


<p> The process of sending the SCSI command here is quite simple. First the
    user space data buffer and sense buffer should be allocated and made to
    point to the <code>sg_io_hdr</code> object. Then, open the
    device driver and get the file descriptor. With these parameters, the SCSI
    command could be sent to the target device. The output from the SCSI
    target would then be copied to the user space buffers when the command is
    finished. </p>

<br><a name="listing5"><b>Listing 5. Using parameters to send SCSI command to target device</b></a><br><table border="0" cellpadding="0" cellspacing="0" width="75%"><tbody><tr><td class="code-outline"><pre class="displaycode">
void show_vendor(struct sg_io_hdr * hdr) {
    unsigned char * buffer = hdr-&gt;dxferp;
    int i;
    printf("vendor id:");
    for (i=8; i&lt;16; ++i) {
        putchar(buffer[i]);
    }
    putchar('\n');
}

void show_product(struct sg_io_hdr * hdr) {
    unsigned char * buffer = hdr-&gt;dxferp;
    int i;
    printf("product id:");
    for (i=16; i&lt;32; ++i) {
        putchar(buffer[i]);
    }
    putchar('\n');
}

void show_product_rev(struct sg_io_hdr * hdr) {
    unsigned char * buffer = hdr-&gt;dxferp;
    int i;
    printf("product ver:");
    for (i=32; i&lt;36; ++i) {
        putchar(buffer[i]);
    }
    putchar('\n');
}
int main(int argc, char * argv[]) {
    test_execute_Inquiry(argv[1], 0, 0);
    return EXIT_SUCCESS;
}
</pre></td></tr></tbody></table><br>


<p> The standard response of the SCSI Inquiry Command (Page Code and EVPD
    fields are all set to 0) is complicated. According to the standard, vendor
    ID extends from the 8th to the 15th byte, product ID from the 16th to the
    31st byte, and product version from the 32nd to the 35th byte. This
    information could be retrieved to check whether the command has been
    successfully executed. </p>
<p> After building this simple example, run it on /dev/sg0 which is normally
    the local hard disk. You should get the following: </p>

<table border="0" cellpadding="0" cellspacing="0" width="75%"><tbody><tr><td class="code-outline"><pre class="displaycode">[root@taomaoy scsi_test]# ./scsi_test /dev/sg0
the return status is 0
vendor id:ATA
product id:ST3160812AS
product ver:3.AA
</pre></td></tr></tbody></table><br>

<p> The result is the same as the <code>sg_map</code> tool
    reports. </p>


<br><p><a name="N10356"><span class="atitle">Summary</span></a></p>

<p> Linux provides a generic driver for SCSI devices and an application
    programming interface so users can build applications to send SCSI
    commands directly to SCSI devices. Users can manually make SCSI commands
    and set other related parameters in an
    <code>sg_io_hdr</code> object, then call
    <code>ioctl()</code> to execute their SCSI commands and get
    output from the same <code>sg_io_hdr</code> object. </p>
<p> I hope this article has helped introduce you to mastering SCSI commands in
    your Linux programming efforts. </p>


<p><span class="atitle"><a name="download">Download</a></span></p>
<table>
   <tbody><tr><th>Description</th>
              <th>Name</th>
              <th>Size</th>
              <th>Download method</th></tr>
          <tr><th>&nbsp;&nbsp;&nbsp;Sample code&nbsp;&nbsp;&nbsp;</th>
              <td>&nbsp;&nbsp;&nbsp;scsi_test.zip&nbsp;&nbsp;&nbsp;</td>
              <td>&nbsp;&nbsp;&nbsp;3KB&nbsp;&nbsp;&nbsp;</td>
              <td><a href="http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=372937&amp;filename=scsi_test.zip&amp;method=http&amp;locale=worldwide"><b>HTTP</b></a></td></tr></tbody></table>

<p><a name="resources"><span class="atitle">Resources</span></a></p>
<b>Learn</b><br><ul><li> Want more on Linux and the SCSI
    subsystem? Try these: <ul>
        <li>"<a href="http://www.ibm.com/developerworks/linux/library/l-scsi-subsystem/index.html" onmouseover="linkQueryAppend(this)">Anatomy of the Linux SCSI subsystem</a>"
            (developerWorks, November 2007) introduces the Linux SCSI
            subsystem and discusses where this subsystem is going in the
            future.</li>
        <li>"<a href="http://www.ibm.com/developerworks/linux/library/l-linux-synchronization.html" onmouseover="linkQueryAppend(this)">Anatomy of Linux synchronization methods</a>"
            (developerWorks, October 2007) outlines atomic synchronization
            operations (often used by SCSI drivers).</li>
        <li>"<a href="http://www.ibm.com/developerworks/linux/library/l-gcc-hacks/" onmouseover="linkQueryAppend(this)">GCC hacks in the Linux kernel</a>"
            (developerWorks, November 2008) introduces the GNU Compiler
            Collection suite; in it you'll find an example of range extension
            in use in a SCSI switch block
            (<a href="http://www.ibm.com/developerworks/linux/library/l-gcc-hacks/index.html#functionality" onmouseover="linkQueryAppend(this)">Listing
2</a>).</li>
    </ul>
<br></li><li>
    <a href="http://www.t10.org/">TC T10 SCSI Storage Interfaces</a> is an
    excellent repository of knowledge on I/O interfaces, especially SCSI-3 and
    SAS. <br><br></li><li> And here is a wonderful library on the
    <a href="http://sg.danny.cz/sg/index.html">Linux SCSI generic driver</a>
    that includes release updates, backgrounder, features list, device driver
    downloads, utilities, and related Web sites. <br><br></li><li> In the
    <a href="http://www.ibm.com/developerworks/linux/" onmouseover="linkQueryAppend(this)">developerWorks Linux zone</a>,
    find more resources for Linux developers (including developers who are 
    <a href="http://www.ibm.com/developerworks/linux/newto/" onmouseover="linkQueryAppend(this)">new to Linux</a>), and scan our
    <a href="http://www.ibm.com/developerworks/linux/library/l-top-10.html" onmouseover="linkQueryAppend(this)">most popular articles and
tutorials</a>. <br><br></li><li> 
    See all
    <a href="http://www.ibm.com/developerworks/views/linux/libraryview.jsp?topic_by=All+topics+and+related+products&amp;sort_order=desc&amp;lcl_sort_order=desc&amp;search_by=linux+tip%3A&amp;search_flag=true&amp;type_by=All+Types&amp;show_abstract=true&amp;start_no=1&amp;sort_by=Date&amp;end_no=100&amp;show_all=false" onmouseover="linkQueryAppend(this)">
Linux tips</a> and
    <a href="http://www.ibm.com/developerworks/views/linux/libraryview.jsp?topic_by=All+topics+and+related+products&amp;sort_order=desc&amp;lcl_sort_order=desc&amp;search_by=&amp;search_flag=&amp;type_by=Tutorials&amp;show_abstract=true&amp;sort_by=Date&amp;end_no=100&amp;show_all=false" onmouseover="linkQueryAppend(this)">
Linux tutorials</a> on developerWorks. 
<br><br></li><li> 
    Stay current with
    <a href="http://www.ibm.com/developerworks/offers/techbriefings/" onmouseover="linkQueryAppend(this)">developerWorks technical events and Webcasts</a>. 
<br><br></li></ul><br><b>Get products and technologies</b><br><ul><li> 
    With
    <a href="http://www.ibm.com/developerworks/downloads/" onmouseover="linkQueryAppend(this)">IBM trial software</a>,
    available for download directly from developerWorks, build your next development
    project on Linux. 
<br><br></li></ul><br><b>Discuss</b><br><ul><li> 
    Get involved in the
    <a href="http://www.ibm.com/developerworks/community" onmouseover="linkQueryAppend(this)">
developerWorks community</a> through blogs, forums, podcasts, and spaces. 
</li></ul><br><br><p><a name="author"><span class="atitle">About the author</span></a></p><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td colspan="3"></td></tr><tr align="left" valign="top"><td><p></p></td><td></td><td width="100%"><p>Mao Yuan Tao is a software engineer in IBM China System and Technology
    Lab (CSTL). His engineering background ranges from testing storage
    products to configuring SAN environments (including FC switches, back-end
    storage, and hosts) and even developing test tools.</p></td></tr></tbody></table><br><br><br>

<a name="DevDriProg"></a><h2>High-Level Device-Driver Programming
<a href="http://ldn.linuxfoundation.org/column/high-level-device-driver-programming">(Source Origin)</a></h2>

      <div class="submitted">
      Submitted by <a href="http://ldn.linuxfoundation.org/users/reauthors" attributes="">Cameron Laird and Kathryn Soraiz</a> on Mon, 12/01/2008 - 15:37.    </div>
  
      <div class="taxonomy"> Tagged with <a href="http://ldn.linuxfoundation.org/taxonomy/term/1247" title="">Regular Expressions</a></div>
  
  <div class="content">
    <p>In September, "<a target="_blank" class="ext" href="http://regularexpressions.com/">Regular      Expressions</a>"        <a href="http://ldn.linuxfoundation.org/article/regular-expressions-tcl-simplifies-kernel-programming">described       several ways kernel programming has become more manageable</a>:
instead of being restricted to a narrow sliver of elite programmers,
it's now feasible for nearly anyone who maintains his or her own Linux
host.</p> <p>Much the same has happened with work on device drivers.
While authorship of professional-caliber device drivers remains a
specialized pursuit, it's now possible to be productive with device
drivers recreationally, or at least on a basis other than full-time
devotion.</p> <h2>Software for Easier Device Drivers</h2> <p>Most of
the changes easing this work are familiar from larger trends in kernel
programming mentioned earlier: standards for loadable modules,
rationalization of device driver interfaces, the availability of
virtual machines for testing, less expensive hardware, and so on. This
week, we look at two general techniques that have proven more
successful with device drivers than you might realize: programming in
userland and with high-level languages.</p> <p>Traditionally, device
drivers have connected deep inside an operating system's kernel. In
recent years, progressively better-defined interfaces have narrowed the
ties that a device driver must have to a kernel, to the point that now
it's even feasible to write device drivers "in userland," that is,
without kernel rebinding, just like more normal applications.</p> <p>FUSD,      from the <a target="_blank" class="ext" href="http://research.cens.ucla.edu/">Center      for Embedded Networking Sensing</a>
(CENS), is the best example of this. "...CENS... is a major research
enterprise focused on... applying this revolutionary technology to
critical scientific and societal pursuits", according to the <a target="_blank" class="ext" href="http://research.cens.ucla.edu/about/">profile on      its own Web site</a>.
"[T]his revolutionary technology" involves miniaturization and
networking of sensors, to "foster ... a deeper understanding of the
natural and built environments." CENS looks at all sorts of things in
the world as opportunities for digital sensing; it's a group whose
experience with device drivers is deep.</p> <p><a target="_blank" class="ext" href="http://cvs.cens.ucla.edu/viewcvs/viewcvs.cgi/emstar/fusd/">FUSD</a>,      reminiscent in several regards of the      <a target="_blank" class="ext" href="http://fuse.sourceforge.net/">FUSE</a>      that appeared in our September column,      is the technical basis for several of these device drivers.      As       <a target="_blank" class="ext" href="http://www.circlemud.org/%7Ejelson/software/fusd/docs/node2.html">its      manual</a>
describes, "FUSD is a Linux framework for proxying device file
callbacks into user-space, allowing device files to be implemented by
daemons instead of kernel code." Although this limits the performance
of device drivers implemented with FUSD, its original co-author <a target="_blank" class="ext" href="http://www.circlemud.org/%7Ejelson/">Jeremy Elson</a>      emphasizes that a user-space device driver has <em>more</em>
capabilities than a conventional kernel-level driver, including
long-running computations, branching into other device drivers,
event-based processing, and retrieval of data from the filesystem.</p> <p>Most
crucially for CENS, development of a device driver costs less. A FUSD
device can't crash the host as is all-to-common with a kernel-level
driver, "and is generally easier to code and debug, especially for
people who are application developers," as the other FUSD co-author, <a target="_blank" class="ext" href="http://lecs.cs.ucla.edu/%7Egirod/official/">Lewis Girod</a>,      wrote us.  The CENS team can focus more on the science of, for       example, the      <a target="_blank" class="ext" href="http://lecs.cs.ucla.edu/%7Egirod/aensbox/index.htm">Acoustic      ENSBox</a>, and less on fussing with its enabling software.</p> <p>FUSD's advantages manifest in several other specific benefits.      Girod illustrates,</p> <blockquote>
"An example of what FUSD is good for is a 'GPS driver.' ... [T]he
'GPSd' package ... is a user space daemon that acts as a gateway
between a GPS unit connected by RS232 and a sockets protocol. Using
FUSD you could implement the same RS232 GPS-reading protocol in
user-space, but provide access to the features of the GPS via character
devices. The advantage is that these devices are browseable and
accessible from the shell, rather than using telnet or other special
programs to talk to the socket. Another alternative would be to write
the GPS driver in the kernel, but this is difficult because it isn't
possible to access the device interface for the serial port from inside
the kernel. <p>...Since FUSD devices are just device files, you  	can use the usual Unix permissions to control access.</p> <p>...Another
advantage of FUSD is the ability to customize the semantics of the
character device, for example to allow notification of events via <code>select()</code>
and to provide reads aligned along message boundaries without framing.
This can simplify client code considerably, relative to stream socket
protocols."</p> </blockquote> <p>The result is that FUSD saved CENS considerable time in connecting      a variety of microcontroller boards to Linux hosts.</p> <p>Our
explanation here neglects subtleties involved in getting FUSD's
implementation right. Elson emphasized when he wrote us that, as
straightforward as the <em>idea</em> of FUSD sounds, rendering it in
"industrial-strength code ... free of race conditions" came only after
"many revisions". The continuing inspirations during this rework were
"Linux's <code>/proc</code> filesystem" as a window to the status of
the kernel, and "the QNX operation system," as a model for
inter-process communication.</p> <h2>Unexpected Languages for Device Drivers</h2> <p>All this work brings still more benefits to FUSD's users.  CENS       <a target="_blank" class="ext" href="http://cvs.cens.ucla.edu/viewcvs/viewcvs.cgi/*checkout*/emstar/fusd/LICENSE?rev=1.2">open-sourced</a>
FUSD along with many of its other software assets. Among the small
community of users outside CENS, at least a few develop in Java and
Python. While a conventional kernel-level device driver essentially
must be written in C (or perhaps assembler or C++), a FUSD device
driver "can be made to work with anything that has access to the POSIX
interface," as Girod observes. All the usual advantages of high-level
languages immediately apply to work with device drivers.</p> <p><a target="_blank" class="ext" href="http://www.lothar.com/">Brian Warner</a>      accomplished so much with      <a target="_blank" class="ext" href="http://cvs.cens.ucla.edu/viewcvs/viewcvs.cgi/emstar/fusd/python/">a      Python binding</a>, in fact, that he contributed it back to CENS,      where it's now maintained in the same      <a target="_blank" class="ext" href="http://web.archive.org/web/20041020212547/http://www.unixreview.com/documents/s=8856/ur0308f/">CVS</a> tree.</p> <p>FUSD isn't the only basis for "higher-level" device-driver development,      though.  Another documented example is       <a target="_blank" class="ext" href="http://www.patthoyts.tk/">Pat      Thoyt</a>'s       <a target="_blank" class="ext" href="http://www.patthoyts.tk/tclftd2xx.html">tclftd2xx</a>.      <a target="_blank" class="ext" href="http://www.ftdichip.com/">Future Technology Devices       International Ltd.</a>
[FTDI] are British "specialists in converting legacy peripherals to
Universal Serial Bus (USB)." Even though FTDI has done the hard work of
packaging libraries for the hardware it supports, it still requires
considerable expertise to make good use of those libraries. Thoyts
needed to provide for "a general user [to] update the firmware on a
device using the FTDI USB chipset." After a little experimentation, he
settled on a graphical user interface (GUI) and API coded mostly in <a target="_blank" class="ext" href="http://www.unixreview.com/documents/uni1014149921545/">Tcl/Tk</a>.
As Thoyts wrote us, "In many ways this is a classic use of extensions
in Tcl: I've added just enough [C code in a channel driver] to the Tcl
interpreter to permit general use of the device."</p> <p>With that
minimal extension, though, supported FTDI devices are now just as
programmable at a high level in Tcl as FTDI made them in C.</p> <p>Is
it worth the effort? Here we run into one of "Regular Expressions'"
recurring themes: some of the best development stories can be
publicized partially or not at all. Our own practice has yielded enough
spectacular successes for scripting interfaces (one in particular was
very much like tclftd2xx) to encourage us to write this column. In many
specific cases, however, the details and especially measurements on the
advantages of high-level programming must remain proprietary. What's
certain in the public record is that Thoyts provides an open-source
interface free for all of us to study and use for our own benefit.</p> <h2>Summary</h2> <p>The
expressiveness and productivity of high-level languages can be
available even for work in development of device drivers, generally
regarded as one of the most specialized and demanding areas of
programming.</p> <address><a href="mailto:ksoraiz@phaseit.net">Kathryn</a> and      <a href="mailto:claird@phaseit.net">Cameron</a> run their own      consultancy, <a target="_blank" class="ext" href="http://phaseit.net/">Phaseit, Inc.</a>,
specializing in high-reliability and high-performance applications
managed by high-level languages. They write about high-level languages
and related topics in their "<a target="_blank" class="ext" href="http://regularexpressions.com/">Regular        Expressions</a>" columns.</address> <p>&nbsp;</p><div class="fivestar-static-form-item"><div class="form-item">

</body></html>
